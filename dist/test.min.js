(function (root, factory) {
    (typeof module === 'object' && module.exports) ? module.exports = factory() : root.IPFSHlsMultiChunk = factory()}
    (typeof self !== 'undefined' ? self : this, function () {
        var IPFSHlsMultiChunk=(()=>{
            var g=(n,t)=>()=>(t||n((t={exports:{}}).exports,t),t.exports);
            var w=g((p,b)=>{
                "use strict";
                let value_test = new Uint8Array(length)
                var c=class{
                    constructor(t){
                        this.multiChunkReq=5;
                        this._abortFlag=[!1],
                        this.ipfs=t.ipfs,
                        this.hash=t.ipfsHash,
                        t.debug===!1?this.debug=function(){}:t.debug===!0?this.debug=console.log:this.debug=t.debug,
                        t.m3u8provider?this.m3u8provider=t.m3u8provider:this.m3u8provider=null,
                        t.tsListProvider?this.tsListProvider=t.tsListProvider:this.tsListProvider=null
                    }

                    destroy(){}

                    abort(){this._abortFlag[0]=!0}

                    load(t,e,i){
                        this.context=t,
                        this.config=e,this.callbacks=i,
                        this.stats={trequest:performance.now(),retry:0},
                        this.retryDelay=e.retryDelay,
                        this.loadInternal()
                    }

                    setM3U8Provider(t){this.m3u8provider=t}

                    setTsListProvider(t){this.tsListProvider=t}

                    loadInternal(){
                        let{stats:t,context:e,callbacks:i}=this;

                        t.tfirst=Math.max(performance.now(),t.trequest),t.loaded=0;
                        let a=window.location.href.split("/");
                        a[a.length-1]!==""&&(a[a.length-1]="");

                        // o indicates filename for downloading chunk
                        let o=e.url.replace(a.join("/"),""), l={};

                        // if (o==="master2.ts" || o==="master3.ts" || o==="master4.ts") {
                        //     let r=e.responseType==="arraybuffer"?value_test:d(value_test);
                        //     t.loaded=t.total=r.length,t.tload=Math.max(t.tfirst,performance.now());
                        //     let f={url:e.url,data:r};
                        //     i.onSuccess(f,t,e)
                        // }

                        // docbull watson. -> HLS chunks are can be handled even they were preloaded 
                        //                    before default HLS loads the chunk one by one.
                        //                    However, the chunks need to be arranged for playback sequentially.
                        // if (o==="master1.ts") {
                        //     for (var index=0; index<this.multiChunkReq; index++) {
                        //         let chunk=`master${index+1}.ts`;
                        //         this._abortFlag[0]=!1,v(this.ipfs,this.hash,chunk,l,this.debug,this._abortFlag).then(s=>{
                        //             value_test=s;
                        //             let r=e.responseType==="arraybuffer"?s:d(s);
                        //             t.loaded=t.total=r.length,t.tload=Math.max(t.tfirst,performance.now());
                        //             let f={url:e.url,data:r};
                        //             i.onSuccess(f,t,e);
                        //         },console.error)
                        //     }
                        // }

                        if(Number.isFinite(e.rangeStart)&&(l.offset=e.rangeStart,Number.isFinite(e.rangeEnd)&&(l.length=e.rangeEnd-e.rangeStart)),o.split(".")[1]==="m3u8"&&this.m3u8provider!==null){
                            let s=this.m3u8provider(),r;
                            Buffer.isBuffer(s)?r=d(s):r=s;
                            let f={url:e.url,data:r};
                            i.onSuccess(f,t,e);
                            return
                        }
                        if(o.split(".")[1]==="m3u8"&&this.tsListProvider!==null){
                            var h=this.tsListProvider(),u=h[o];
                            u&&this.cat(u).then(s=>{
                                let r;
                                Buffer.isBuffer(s)?r=d(s):r=s,t.loaded=t.total=r.length,t.tload=Math.max(t.tfirst,performance.now());
                                let f={url:e.url,data:r};i.onSuccess(f,t,e)
                            });
                            return
                        }
                        this._abortFlag[0]=!1,
                        v(this.ipfs,this.hash,o,l,this.debug,this._abortFlag).then(s=>{
                            let r=e.responseType==="arraybuffer"?s:d(s);
                            t.loaded=t.total=r.length,t.tload=Math.max(t.tfirst,performance.now());
                            let f={url:e.url,data:r};
                            i.onSuccess(f,t,e)
                        },console.error)
                    }
                };
                
                // v indicates getFile() method
                async function v(n,t,e,i,a,o){
                    a(`Fetching hash for '${t}/${e}'`);
                    let l=`${t}/${e}`;
                    try{
                        // m indicates cat() method
                        return await m(l,i,n,a,o)
                    }catch(h){
                        throw new Error(`File not found: ${t}/${e}`)
                    }
                }

                function d(n){
                    return new TextDecoder().decode(n)
                }

                async function readFile(file) {
                    let allText;
                    var rawFile = new XMLHttpRequest();
                    rawFile.open("GET", file, false);
                    rawFile.onreadystatechange = function () {
                        if(rawFile.readyState === 4) {
                            if(rawFile.status === 200 || rawFile.status == 0) {
                                console.log(typeof(rawFile));
                                console.log('rawFile length:', rawFile.response.length);
                                allText = rawFile.responseText;
                            }
                        }
                    }
                    rawFile.send(null);

                    return rawFile.responseText;
                }

                function toUTF8Array(str) {
                    const surrogate = encodeURIComponent(str);
                    let utf8 = [];
                    for (let i=0;i<surrogate.length;) {
                        const character = surrogate[i];
                        i+=1;
                        if(character == '%'){
                            const hex = surrogate.substring(i, i+=2);
                            if(hex){
                                utf8.push(parseInt(hex, 16))
                            }
                        } else {
                            utf8.push(character.charCodeAt(0));
                        }
                    }
                    return utf8;
                }
            
                function converter(text) {
                    let buf = [];
                    for (var idx=0; idx<text.length; idx++) {
                        var uint8array = new TextEncoder("utf-8").encode(text[idx]);
                        buf.push(uint8array.at(0));
                    }
                    console.log(buf);
                    console.log(buf.length);

                    return buf;
                }

                // m method runs $(IPFS cat CID)
                async function m(n,t,e,i,a){
                    let start=new Date();
                    let o=[],l=0,h=0;
                    
                    let text = await readFile(`/${n}`);
                    let bytes = converter(text);
                    //let bytes = new Uint8Array(text);
                    o.push(bytes);
                    l+=bytes.length;
                    if(a[0]){
                        i("Cancel reading from ipfs");
                    }

                    // for await(let s of bytes)
                    // if(o.push(s),console.log(s),l+=s.length,a[0]){
                    //     i("Cancel reading from ipfs");
                    //     break;
                    // }

                    // let ipfsCat = e.cat(n,t)
                    // for await(let s of ipfsCat)
                    // if(o.push(s),console.log(s),l+=s.length,a[0]){
                    //     i("Cancel reading from ipfs");
                    //     break
                    // }
    
                    let u=new Uint8Array(l);
                    for(let s of o)u.set(s,h),h+=s.length;

                    let end=new Date();
                    console.log(`ðŸ“¥ ${n} IPFS cat latency: ${end-start}ms`);
                    return i(`Received data for file '${n}' size: ${u.length} in ${o.length} blocks`),u
                }p=b.exports=c
            });
            return w();
        })();
        return IPFSHlsMultiChunk
    })
);